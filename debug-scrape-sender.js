const axios = require('axios');
const fs = require('fs');
const path = require('path');

console.log('üêõ Debug Scrape Sender External Panel...\n');

// External panel configuration (updated)
const EXTERNAL_PANEL = {
    domain: 'https://panel-two.ndikafath.com',
    plta: 'ptla_6OSbM8oAbeedeLw0xm2tJeEK5s65GsaPAEsZs8s4yGC',
    pltc: 'ptlc_3RbaGq18XEwuxnwz8jIxQ589wzgsNlekBislRs78ba1'
};

const OUTPUT_SCRAPE_SENDER_DIR = 'output-scrape-sender';

console.log('üìã External Panel Configuration:');
console.log(`üåê Domain: ${EXTERNAL_PANEL.domain}`);
console.log(`üîë PLTA: ${EXTERNAL_PANEL.plta.substring(0, 10)}...`);
console.log(`üîë PLTC: ${EXTERNAL_PANEL.pltc.substring(0, 10)}...`);

// External Panel API helper
class ExternalPteroAPI {
    static async appRequest(endpoint, method = 'GET', data = null) {
        try {
            const url = `${EXTERNAL_PANEL.domain}/api/application/${endpoint}`;
            const config = {
                method,
                url,
                headers: {
                    'Authorization': `Bearer ${EXTERNAL_PANEL.plta}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                },
                timeout: 30000
            };

            if (data) config.data = data;

            console.log(`üåê App API Request: ${method} ${url}`);
            await new Promise(resolve => setTimeout(resolve, 2000));

            const response = await axios(config);
            console.log(`‚úÖ App API Response: ${response.status}`);

            return response.data;
        } catch (error) {
            console.error(`‚ùå App API Error: ${error.response?.status} - ${error.message}`);
            throw error;
        }
    }

    static async clientRequest(endpoint, method = 'GET', data = null) {
        try {
            const url = `${EXTERNAL_PANEL.domain}/api/client/${endpoint}`;
            const config = {
                method,
                url,
                headers: {
                    'Authorization': `Bearer ${EXTERNAL_PANEL.pltc}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                },
                timeout: 30000
            };

            if (data) config.data = data;

            console.log(`üåê Client API Request: ${method} ${url}`);
            await new Promise(resolve => setTimeout(resolve, 2000));

            const response = await axios(config);
            console.log(`‚úÖ Client API Response: ${response.status}`);

            return response.data;
        } catch (error) {
            console.error(`‚ùå Client API Error: ${error.response?.status} - ${error.message}`);
            throw error;
        }
    }

    static async getAllServers() {
        try {
            const response = await this.appRequest('servers');
            return response.data || [];
        } catch (error) {
            console.log('‚ùå Cannot get servers via API');
            return [];
        }
    }
}

// Clean JSON content function
function cleanJsonContent(content) {
    if (!content || typeof content !== 'string') {
        return content;
    }
    
    // Remove line numbers like "1{...}" at the beginning
    let cleaned = content.replace(/^\d+\{/, '{');
    
    // Remove any leading/trailing whitespace
    cleaned = cleaned.trim();
    
    return cleaned;
}

// Debug scraping function
async function debugScrapeExternalSender() {
    try {
        console.log('\nüöÄ Starting debug scrape external sender...');
        
        // Get servers from external panel
        console.log('üì° Getting servers from external panel...');
        const externalServers = await ExternalPteroAPI.getAllServers();

        console.log(`üìä External panel servers: ${externalServers.length}`);
        
        if (externalServers.length === 0) {
            console.log('‚ùå No external servers found');
            return;
        }

        let scrapedCount = 0;
        let skippedCount = 0;
        let errorCount = 0;
        const scrapedFiles = [];

        // Create output directory
        const outputDir = path.join(__dirname, OUTPUT_SCRAPE_SENDER_DIR);
        console.log(`üìÅ Creating output directory: ${outputDir}`);
        
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
            console.log(`‚úÖ Created output directory: ${outputDir}`);
        } else {
            console.log(`‚úÖ Output directory already exists: ${outputDir}`);
        }

        // Test with first 3 servers
        const testServers = externalServers.slice(0, 3);
        console.log(`\nüîç Testing with first ${testServers.length} servers...`);

        for (const externalServer of testServers) {
            try {
                const externalUuid = externalServer.attributes.uuid;
                const externalName = externalServer.attributes.name;

                console.log(`\nüîç Processing external server: ${externalName} (${externalUuid})`);

                // Check if external server has creds.json via API
                let credsFound = false;
                let credsContent = null;
                let foundPath = '';

                // Method 1: Check files in /files/session directory
                try {
                    console.log(`üìÅ Method 1: Checking /files/session directory for ${externalName}...`);
                    const sessionFilesResponse = await ExternalPteroAPI.clientRequest(`servers/${externalUuid}/files/list?directory=%2Ffiles%2Fsession`, 'GET');
                    
                    console.log(`üìä Session response status: ${sessionFilesResponse ? 'OK' : 'NULL'}`);
                    
                    if (sessionFilesResponse && sessionFilesResponse.data && sessionFilesResponse.data.length > 0) {
                        console.log(`üìã Found ${sessionFilesResponse.data.length} files in /files/session directory`);
                        
                        // List all files for debugging
                        sessionFilesResponse.data.forEach(file => {
                            const type = file.attributes.is_file ? 'üìÑ' : 'üìÅ';
                            console.log(`   ${type} ${file.attributes.name}`);
                        });
                        
                        // Look for JSON files
                        const jsonFiles = sessionFilesResponse.data.filter(file => 
                            file.attributes.is_file && file.attributes.name.endsWith('.json')
                        );
                        
                        console.log(`üîç Found ${jsonFiles.length} JSON files in /files/session`);
                        
                        if (jsonFiles.length > 0) {
                            const credsFile = jsonFiles.find(file => file.attributes.name === 'creds.json') || jsonFiles[0];
                            console.log(`üìÑ Selected JSON file: ${credsFile.attributes.name}`);
                            foundPath = `/files/session/${credsFile.attributes.name}`;
                            
                            // Try to read the file content
                            try {
                                console.log(`üìñ Reading file content from: ${foundPath}`);
                                const fileContentResponse = await ExternalPteroAPI.clientRequest(
                                    `servers/${externalUuid}/files/contents?file=%2Ffiles%2Fsession%2F${encodeURIComponent(credsFile.attributes.name)}`, 
                                    'GET'
                                );
                                
                                console.log(`üìä File content response type: ${typeof fileContentResponse}`);
                                console.log(`üìä File content length: ${fileContentResponse ? (typeof fileContentResponse === 'string' ? fileContentResponse.length : 'Not string') : 'NULL'}`);
                                
                                if (fileContentResponse && typeof fileContentResponse === 'string' && fileContentResponse.trim().length > 0) {
                                    credsContent = fileContentResponse;
                                    credsFound = true;
                                    console.log(`‚úÖ Successfully read ${credsFile.attributes.name} from /files/session/ in ${externalName}`);
                                    console.log(`üìä Content preview: ${fileContentResponse.substring(0, 100)}...`);
                                } else {
                                    console.log(`‚ö†Ô∏è File content is empty or invalid format for ${credsFile.attributes.name}`);
                                }
                            } catch (readError) {
                                console.log(`‚ùå Failed to read ${credsFile.attributes.name}: ${readError.response?.status} - ${readError.message}`);
                            }
                        } else {
                            console.log(`‚ö†Ô∏è No JSON files found in /files/session for ${externalName}`);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è /files/session directory is empty or not accessible for ${externalName}`);
                    }
                } catch (sessionError) {
                    console.log(`‚ùå Cannot access /files/session directory for ${externalName}: ${sessionError.response?.status} - ${sessionError.message}`);
                }

                // Final check if we found any creds
                if (!credsFound || !credsContent || credsContent.trim().length === 0) {
                    skippedCount++;
                    console.log(`‚è≠Ô∏è Skipping ${externalName}: No valid creds.json found via API`);
                    continue;
                }

                console.log(`üîß Processing creds content for ${externalName}...`);
                console.log(`üìä Raw content length: ${credsContent.length}`);

                // Clean and validate JSON content
                try {
                    const cleanedContent = cleanJsonContent(credsContent);
                    console.log(`üßπ Cleaned content length: ${cleanedContent.length}`);
                    
                    // Validate JSON
                    const jsonData = JSON.parse(cleanedContent);
                    console.log(`‚úÖ Valid JSON with ${Object.keys(jsonData).length} properties`);

                    // Create safe filename from server name
                    const safeFileName = externalName.replace(/[^a-zA-Z0-9-_]/g, '_') + '.json';
                    const outputFilePath = path.join(outputDir, safeFileName);

                    console.log(`üíæ Saving to: ${outputFilePath}`);

                    // Save to output-scrape-sender folder
                    fs.writeFileSync(outputFilePath, cleanedContent, 'utf8');
                    
                    // Verify file was written
                    if (fs.existsSync(outputFilePath)) {
                        const fileStats = fs.statSync(outputFilePath);
                        console.log(`‚úÖ File saved successfully - Size: ${fileStats.size} bytes`);
                        
                        scrapedCount++;
                        scrapedFiles.push({
                            serverName: externalName,
                            serverUuid: externalUuid,
                            fileName: safeFileName,
                            filePath: outputFilePath,
                            foundPath: foundPath,
                            fileSize: fileStats.size
                        });

                        console.log(`‚úÖ Scraped sender from ${externalName} ‚Üí ${safeFileName} (${fileStats.size} bytes)`);
                    } else {
                        console.log(`‚ùå File was not saved: ${outputFilePath}`);
                        errorCount++;
                    }

                } catch (jsonError) {
                    console.log(`‚ùå Invalid JSON content for ${externalName}: ${jsonError.message}`);
                    errorCount++;
                    continue;
                }

                // Small delay
                await new Promise(resolve => setTimeout(resolve, 3000));

            } catch (error) {
                errorCount++;
                console.error(`‚ùå Error scraping ${externalServer.attributes.name}:`, error.message);
            }
        }

        // Final results
        console.log(`\nüìä Final Debug Results:`);
        console.log(`üì§ Total Scraped: ${scrapedCount}`);
        console.log(`‚è≠Ô∏è Dilewati: ${skippedCount}`);
        console.log(`‚ùå Error: ${errorCount}`);
        console.log(`üìÅ Output Directory: ${outputDir}`);

        if (scrapedCount > 0) {
            console.log(`\nüìã Scraped Files:`);
            scrapedFiles.forEach((file, index) => {
                console.log(`${index + 1}. ${file.serverName} ‚Üí ${file.fileName} (${file.fileSize} bytes)`);
                console.log(`   üìÅ Source: ${file.foundPath}`);
                console.log(`   üíæ Saved: ${file.filePath}`);
            });
        }

        console.log('\n‚úÖ Debug scraping completed!');

    } catch (error) {
        console.error('‚ùå Debug test failed:', error.message);
    }
}

// Run the debug test
debugScrapeExternalSender().catch(console.error);
